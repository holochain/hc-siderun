#!/bin/bash

# AUTO-GENERATED by build/test.bash - do not edit directly

# make bash a little more strict / deterministic
set -Eeuo pipefail

_SR_VERSION_GIT="ceabcce"

# -- begin source files -- #


###########################################################################
# version.bash
###########################################################################

_SR_VERSION_MAJ=0
_SR_VERSION_MIN=1
_SR_VERSION_PATCH=0
_SR_VERSION="v${_SR_VERSION_MAJ}.${_SR_VERSION_MIN}.${_SR_VERSION_PATCH}+${_SR_VERSION_GIT}"

###########################################################################
# util.bash
###########################################################################

# helpful utility functions

# logging helper
function _sr_log {
  local _FMT="${1}"
  shift 1
  printf "# hc-siderun: " 1>&2
  printf "${_FMT}\n" "${@:-}" 1>&2
}

# fatal exit condition
function _sr_fail {
  _sr_log "${@}"
  _sr_log "FATAL ERROR - aborting"
  exit 1
}

# Return the canonicalized path (works on OS-X like 'readlink -f' on Linux); . is $PWD
function realpath {
    [ "." = "${1}" ] && n=${PWD} || n=${1}; while nn=$( readlink -n "$n" ); do n=$nn; done; echo "$n"
}

###########################################################################
# opt.bash
###########################################################################

# siderun option parsing helper

# print out usage info
function _sr_usage {
  local __CMD="$(basename ${0})"
  echo "usage: ${__CMD} [subcommand] [options]" 1>&2
  echo "       version ${_SR_VERSION}" 1>&2
  echo $'
[subcommands]
 * help    = display this help / usage message

 * version = display version and exit

 * init    = initialize an hc siderun cluster
      -c <name> --cluster <name> : the cluster name, defaults to "default"
      -p <path> --path <path>    : path to the hc app source, defaults to "."

 * list    = list all initialized siderun clusters

 * run     = execute the named siderun cluster
      -c <name> --cluster <name> : the cluster name, defaults to "default"
      -f --follow                : output all node logs

 * del     = delete a named siderun cluster
      -c=<name> --cluster=<name> : the cluster name, defaults to "default"

 * quick   = delete / init / and run in one command
      -c=<name> --cluster=<name> : the cluster name, defaults to "default"
      -p <path> --path <path>    : path to the hc app source, defaults to "."
      -f --follow                : output all node logs

 * clean   = clean up, delete all clusters

[environment]
 * HC_SIDERUN_WORK_DIR - default: "$HOME/.hc-siderun"
 * HC_SIDERUN_MAGIC    - default: "hc-sr.~-~"' 1>&2
  exit 0
}

# @scope-param __KEY
function _sr_strip_key {
  if [[ ${__KEY} == -* ]]; then
    __KEY="${__KEY#*-}"
  fi
  if [[ ${__KEY} == -* ]]; then
    __KEY="${__KEY#*-}"
  fi
}

# @scope-param _SR_O_CMD - sub command
# @scope-param _SR_O_CLUSTER - -c / --cluster
# @scope-param _SR_O_NAME - -n / --name
# @scope-param _SR_O_PATH - -p / --path
function _sr_opt_parse {
  while [ "${#}" -gt 0 ]; do
    case ${1} in
      -*)
        local __KEY=""
        local __VAL=""
        if [[ ${1} == *"="* ]]; then
          local __KEY="${1%%=*}"
          _sr_strip_key
          local __VAL="${1#*=}"
        else
          local __KEY="${1}"
          _sr_strip_key
          case ${__KEY} in
            f|follow)
              ;;
            *)
              shift 1
              local __VAL="${1}"
              ;;
          esac
        fi
        case ${__KEY} in
          f|follow)
            _SR_O_FOLLOW="yes"
            ;;
          c|cluster)
            if [ "${_SR_O_CLUSTER}x" != "x" ]; then
              _sr_fail \
                "illegal multiple cluster flags '${_SR_O_CLUSTER}' + '${__VAL}'"
            fi
            _SR_O_CLUSTER="${__VAL}"
            ;;
          n|name)
            if [ "${_SR_O_NAME}x" != "x" ]; then
              _sr_fail \
                "illegal multiple name flags '${_SR_O_NAME}' + '${__VAL}'"
            fi
            _SR_O_NAME="${__VAL}"
            ;;
          p|path)
            if [ "${_SR_O_PATH}x" != "x" ]; then
              _sr_fail \
                "illegal multiple path flags '${_SR_O_PATH}' + '${__VAL}'"
            fi
            _SR_O_PATH="${__VAL}"
            _SR_O_PATH=$( realpath "${_SR_O_PATH}" )
            ;;
          *)
            _sr_fail "unrecognized flag '${__KEY}'"
            ;;
        esac
        ;;
      *)
        if [ "${_SR_O_CMD}x" != "x" ]; then
          _sr_fail "illegal multiple sub-commands '${_SR_O_CMD}' + '${1}'"
        fi
        _SR_O_CMD="${1}"
        ;;
    esac
    shift 1
  done

  if [ "${_SR_O_CMD}x" == "x" -o "${_SR_O_CMD}" == "help" ]; then
    _sr_usage "${@:-}"
  fi

  if [ "${_SR_O_CMD}" == "version" ]; then
    # print this to stdout
    echo "${_SR_VERSION}"
    exit 0
  fi

  # defaults
  if [ "${_SR_O_CLUSTER}x" == "x" ]; then
    _SR_O_CLUSTER="default"
  fi
  if [ "${_SR_O_PATH}x" == "x" ]; then
    _SR_O_PATH=$( realpath . )
  fi
}

###########################################################################
# validate.bash
###########################################################################

# validate sanity of environment
function _sr_validate_env {
  if ! ( (screen -v || true) | grep 'Screen version' > /dev/null); then
    _sr_fail "Fatal: %s" \
      "'screen' command not found, 'sudo apt-get install screen'?"
  fi

  if ! (bs -v | grep 'bs version' > /dev/null); then
    _sr_fail "Fatal: %s" \
      "'bs' command not found / did you set up your holochain PATH?"
  fi

  if ! (hcdev -v | grep 'hcdev version' > /dev/null); then
    _sr_fail "Fatal: %s" \
      "'hcdev' command not found / did you set up your holochain PATH?"
  fi

  if ! (hcadmin -v | grep 'hcadmin version' > /dev/null); then
    _sr_fail "Fatal: %s" \
      "'hcadmin' command not found / did you set up your holochain PATH?"
  fi
}

###########################################################################
# cmd.init.bash
###########################################################################

# cmd init hc-siderun subcommand implementation

# initialize one node
function _sr_cmd_init_node {
  local __INDEX="${1}"
  local __NAME="node${__INDEX}"
  local __DHT_PORT="$((10100 + ${i}))"
  local __WEB_PORT="$((10000 + ${i}))"
  local __WS=$(cd "${_SR_C_DIR}" && mktemp -d \
    -t "${_SR_MAGIC}.${__NAME}.XXXXXXXXXXXXXX")
  echo "screen -t ${__NAME} bash -c 'hcdev --bootstrapServer 127.0.0.1:10000 --execpath ${__WS} --path \"${_SR_O_PATH}\" --DHTport ${__DHT_PORT} --logPrefix \"${__NAME}: \" --debug web ${__WEB_PORT} 2>&1 | tee ${_SR_C_DIR}/${__NAME}.log'" >> "${_SR_SCREEN_RC}"
  hcadmin --path "${__WS}" init "${__NAME}@test.test" > /dev/null 2>&1
}

# execute the 'init' command
# set up a new cluster set
# @scope-param _SR_O_PATH - -p / --path
function _sr_cmd_init {
  if [ "${_SR_O_PATH}x" == "x" ]; then
    _sr_fail "'-p / --path' flag required for 'join' subcommand"
  fi

  local _SR_C_DIR="${_SR_WORK_DIR}/${_SR_O_CLUSTER}"
  if [ -d "${_SR_C_DIR}" ]; then
    _sr_fail "'${_SR_C_DIR}' exists, aborting"
  fi

  _sr_log "initializing ${_SR_C_DIR}"

  mkdir -p "${_SR_C_DIR}"

  local _SR_SCREEN_RC="${_SR_C_DIR}/cluster.screenrc"
  # If the user already has a .screenrc configuration, harvest some basic configurations from it
  ( [ -r "$HOME/.screenrc" ] && grep "^escape\|^hardstatus" "$HOME/.screenrc" || true ) \
      > "${_SR_SCREEN_RC}"
  cat << EOF >> "${_SR_SCREEN_RC}"
startup_message off
defscrollback 10000
defshell -bash

screen -t bootstrap bash -c 'bs --port 10000 2>&1 | tee ${_SR_C_DIR}/bs.log'
EOF

  for i in 1 2 3; do
    _sr_cmd_init_node "${i}"
  done
}

###########################################################################
# cmd.list.bash
###########################################################################

# cmd list hc-siderun subcommand implementation

function _sr_cmd_list {
  for _SR_O_CLUSTER in $(ls "${_SR_WORK_DIR}"); do
    local _SR_C_DIR="${_SR_WORK_DIR}/${_SR_O_CLUSTER}"
    local _SR_SCREEN_RC="${_SR_C_DIR}/cluster.screenrc"
    if [ -d "${_SR_C_DIR}" -a -f "${_SR_SCREEN_RC}" ]; then
      echo "${_SR_O_CLUSTER}"
    fi
  done
}

###########################################################################
# cmd.run.bash
###########################################################################

# cmd run hc-siderun subcommand implementation

_SR_SCREEN_SOCKET_NAME=""
function _sr_cleanup_screen {
  screen -S "${_SR_SCREEN_SOCKET_NAME}" -X quit > /dev/null 2>&1 || true
  screen -wipe > /dev/null 2>&1 || true
}

function _sr_wait_logs {
  while true; do
    local __COUNT=$(find "${_SR_C_DIR}" -iname \*.log | wc -l)
    echo "log count: ${__COUNT}"
    if (( ${__COUNT} >= 4 )); then
      return
    fi
    sleep .1
  done
}

function _sr_cmd_run {
  local _SR_C_DIR="${_SR_WORK_DIR}/${_SR_O_CLUSTER}"
  if [ ! -d "${_SR_C_DIR}" ]; then
    _sr_fail "'${_SR_C_DIR}' does not exist, aborting"
  fi

  _sr_log "running ${_SR_C_DIR}"

  _SR_SCREEN_SOCKET_NAME="${_SR_MAGIC}.${_SR_O_CLUSTER}"

  _sr_cleanup_screen
  trap _sr_cleanup_screen EXIT

  local _SR_SCREEN_RC="${_SR_C_DIR}/cluster.screenrc"
  screen -DmS "${_SR_SCREEN_SOCKET_NAME}" -c "${_SR_SCREEN_RC}" &
  local __PID="${!}"

  _sr_log "Screen is running, ctrl-c to stop it"
  _sr_log "you should be able to 'screen -r' from another terminal"
  _sr_log "pid = ${__PID}"
  _sr_log "view logs with: "
  _sr_log "  tail -f ${_SR_C_DIR}/*.log"
  _sr_log "\n%s\n%s\n%s" "http://127.0.0.1:10001" "http://127.0.0.1:10002" "http://127.0.0.1:10003"

  if [ "${_SR_O_FOLLOW}" == "yes" ]; then
    _sr_wait_logs
     tail -f $(find "${_SR_C_DIR}" -iname \*.log)
  else
    wait "${__PID}"
  fi
}

###########################################################################
# cmd.del.bash
###########################################################################

# cmd del hc-siderun subcommand implementation

function _sr_cmd_del {
  local _SR_C_DIR="${_SR_WORK_DIR}/${_SR_O_CLUSTER}"
  if [ ! -d "${_SR_C_DIR}" ]; then
    _sr_log "'${_SR_C_DIR}' does not exist, nothing to do"
    return
  fi

  _sr_log "deleting ${_SR_C_DIR}"

  rm "${_SR_C_DIR}/cluster.screenrc" > /dev/null 2>&1 || true

  find "${_SR_C_DIR}" -iname '*.log' -delete > /dev/null 2>&1 || true

  # make cleaning up work dirs a little safer (rm -Rf * yay)
  for __NODE in $(ls "${_SR_C_DIR}"); do
    local __P="${_SR_C_DIR}/${__NODE}"
    if [[ ${__NODE} == "${_SR_MAGIC}"* ]] && [ -d "${__P}" ]; then
      rm -Rf "${__P}"
    fi
  done

  rmdir "${_SR_C_DIR}"
}

###########################################################################
# cmd.clean.bash
###########################################################################

# cmd clean hc-siderun subcommand implementation

function _sr_cmd_clean {
  for _SR_O_CLUSTER in $(ls "${_SR_WORK_DIR}"); do
    local _SR_C_DIR="${_SR_WORK_DIR}/${_SR_O_CLUSTER}"
    if [ -d "${_SR_C_DIR}" ]; then
      _sr_cmd_del
    fi
  done
}

###########################################################################
# cmd.quick.bash
###########################################################################

# cmd quick hc-siderun subcommand implementation
# cleans up the current cluster, re-inits, and runs

function _sr_cmd_quick {
  local _SR_C_DIR="${_SR_WORK_DIR}/${_SR_O_CLUSTER}"
  _sr_log "quick - del(${_SR_C_DIR})"
  _sr_cmd_del
  _sr_log "quick - init(${_SR_C_DIR})"
  _sr_cmd_init
  _sr_log "quick - run(${_SR_C_DIR})"
  _sr_cmd_run
}

###########################################################################
# main.bash
###########################################################################

# entrypoint for hc-siderun tool

# set up some hc tool environment variables
function _hc_tool_env {
  export HC_DEFAULT_BOOTSTRAPSERVER="127.0.0.1:10000"
  export HCLOG_APP_ENABLE=1
  export HCLOG_DHT_ENABLE=1
  export HCLOG_GOSSIP_ENABLE=1
  export HCLOG_DEBUG_ENABLE=1
}

# siderun main entrypoint
function _sr_main {
  # scope variables for _sr_opt_parse
  local _SR_O_CMD=""
  local _SR_O_CLUSTER=""
  local _SR_O_NAME=""
  local _SR_O_PATH=""
  local _SR_O_FOLLOW="no"

  # parse our options
  _sr_opt_parse "${@}"

  # make sure the commands we need exist
  _sr_validate_env

  # make sure hc tools behave how we want them to
  _hc_tool_env

  # scope variables for commands
  local _SR_WORK_DIR="${HC_SIDERUN_WORK_DIR:-${HOME}/.hc-siderun}"
  local _SR_WORK_DIR=$( realpath "${_SR_WORK_DIR}" )
  local _SR_MAGIC="${HC_SIDERUN_MAGIC:-hc-sr.~-~}"

  # delegate to command handlers
  case ${_SR_O_CMD} in
    quick)
      _sr_cmd_quick
      ;;
    init)
      _sr_cmd_init
      ;;
    list)
      _sr_cmd_list
      ;;
    run)
      _sr_cmd_run
      ;;
    del)
      _sr_cmd_del
      ;;
    clean)
      _sr_cmd_clean
      ;;
    *)
      _sr_log "unknown command '${_SR_O_CMD}'"
      _sr_usage "${@:-}"
      ;;
  esac
}

# entrypoint
_sr_main "${@:-help}"
